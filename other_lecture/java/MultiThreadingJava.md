# Многопоточность

### Закон Амдала

Закон Амдала гласит: «Общая скорость параллельной системы определяется 
самым медленным компонентом»

`S(N) = 1/(1-P)+(P/N)`

- S - ускорение
- P - доля вычислений, которые можно распараллелить
- N - количество вычислительных ядер

### Параллелизм 
- Запуск нескольких JVM на одном или на разных компьютеров
  - Нет общей памяти
  - Взаимодействие через файловую систему или сетевое соединение

- Запуск нескольких потоков внутри JVM
  - Есть общая память (неаккуратный доступ к общим данным может их испортить)
  - Обширная поддержка в языке и стандартной библиотеке

### Проблемы параллельных программ
- Гонка (race condition)
- Взаимная блокировка (deadlock)
  - Два потока взаимно ждут необходимые им ресурсы, заблокированные в этот момент другим потоком

### Потоки в Java
- Потоки представлены экземплярами класса java.lang.Thread
Стандартные методы
- String getName()
- long getId()
- boolean isDaemon()
  - флаг, влияющий на то, когда JVM может корректно завершиться. Например, если все потоки являются демонами, то она может завершиться, не дожидаясь их. 
  При этом если есть поток Недемон, то JVM будет ждать его завершения
- StackTraceElement[] getStackTrace()
- ThreadGroup getThreadGroup()

#### ThreadDump
Cписок всех потоков с их состояниями и stack trace'ами. Можно посмотреть В IDE во время выполнения.

#### Создание потоков
- Первый способ
```java
Thread thread = new Thread() {
    @Override
    public void run() {
        // do some work    
    }
}   
```
- Второй способ
```java
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        // do some work
    }
}
Thread thread = new Thread(runnable);
```
Ещё пример
```java
public class MyThread implements Runnable {
    // 1. Наследуем интерфейс

    @Override
    public void run() {

    }

    public static void main(String[] args) {
        Thread thread = new Thread(()-> {});
        thread.start();
        thread.interrupt();
    }
}
```

### Жизненный цикл потока
- Создание объекта Thread
- Запуск `thread.start()`
- Работа
  - выполняется метод run(), thread.isAlive() == true
- Завершение 
  - метод run() закончился или бросил исключение
- Завершённый поток нельзя перезапустить

### Прерывание потока
- `thread.interrupt()`
- Если поток находится в ожидании(sleep, await, join), 
то ожидание прерывается исключением `InterruptedException`
- Иначе у потока просто устанавливается флаг `interrupted` 
  - флаг проверяется методами `interrupted()` и `isInterrupted()`
  - проверять флаг и завершать поток надо самостоятельно
- Если мы хотим дождаться, пока поток закончит выполнение `thread.join()`

>__Пример в demo2__

### Возможности встроенной синхронизации
- Взаимное исключение (пока один поток что-то делает, другие не могут ему помешать)
- Ожидание и уведомление (поток ожидает уведомлений от других потоков)

Ключевое слово synchronized можно использовать следующими способами
> Синхронизированный метод
```java
    public synchronized void doSomething() {
        // ...
    } 
 ```
> Синхронизированный блок внутри метода
```java
  public void doSomething() {
    synchronized(obj) {
        // ...
    }    
  }
```
> Для синхронизированного статического метода:
```java
    class C {
    public static void m() {
        synchronized (C.class) {
            
        }
    }
}
```

То на чём синхронизируется synchronized называется __монитор(monitor)__.
У каждого объекта есть монитор, у каждого класса есть __монитор__.
При синхронизации по некоему __монитору__ это означает, что никакой другой поток не может
синхронизироваться по этому __монитору__.

### Ожидания и уведомления
Выполнение следующих методов допустимо только внутри synchronized:
>- void wait() // приостанавливает выполнение текущего потока и освобождает блокировку захваченного монитора
>- void wait(long millis) // При ожидании с определённым временем - если ресурс не был освобождён поток завершится досрочно
>- void wait(long millis, int nanos)


>- void notify() // заставить проснуться один поток, пытавшиеся захватить ранее монитор указанного объекта
>- void notifyAll() // то же самое только для всех потоков, пытавшихся получить доступ к монитору
 
__Пример Demo3__

## Модель памяти
> Атомарность 

- В Java гарантируется атомарность выполнения след. операций
чтение и запись полей всех типов, кроме long и double, 
происходит атомарно
- Если поле объявлено с модификатором volatile, 
то атомарно читаются и пишутся даже long и double

> Видимость
- Изменения значений полей, сделанные одним потоком, 
могут быть не видны в другом потоке
```java
class A { int a = 0; int b = 0; }
  T1      T2
  |       |
 a=1      |
 b=2      |
  |     prinln(a)    ===> 1
  |     println(b)   ===> 0
```
- Изменения, сделанные одним потоком, 
могут быть видны в другом потоке в ином порядке
- Правила формализованы при помощи отношения __happens-before__
    - Запись volatile-поля happens-before чтения этого поля 
  Пример:
    ```java
    class A { int a = 0; volatile int b = 0; }
    T1           T2
    |            |
    a=1          |
    b=2          |
    event(x)     |
    |          event(z)
    |          prinln(a)    ===> 1
    |          println(b)   ===> 2
  
    // из-за того, что b объявлена как volatile
    // гарантируется, корректность выполнения
    ```
- Освобождение монитора happens-before захват того же монитора
  ```java
  class A { int a = 0; volatile int b = 0; }
  T1              T2
  |               |
  synchronized()  |           
  a=1             |
  b=2             |
  event(x)        |
  |           synchronized()
  |           event(z)
  |           prinln(a)    ===> 1
  |           println(b)   ===> 2
  
  // из-за того, код выполнялся 
  // в одном блоке synchronized() по одному монитору
  // гарантируется, корректность выполнения
  ```
    - thread.start() happens-before thread.run()
  ```java
  class A { int a = 0; volatile int b = 0; }
  T1                T2
  |                 |
  |                 |           
  a=1               |
  b=2               |
  thread.start(T2)  |
  |                run()
  |               prinln(a)    ===> 1
  |               println(b)   ===> 2
  
  // из-за того, код выполнялся 
  // в одном блоке synchronized() по одному монитору
  // гарантируется, корректность выполнения
  ```

    - Завершение thread.run() happens-before выход из thread.join()
    - ...
- Семантика final
